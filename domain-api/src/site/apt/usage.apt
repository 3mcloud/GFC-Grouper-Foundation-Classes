<<<Usage>>>

* Overview

    GFC was designed to allow different kinds of components with different record requires
    to be processes within a similar API.  There is heavy use of Java interfaces to 
    allow development without dictating a rigid class hierarchy.  The interfaces also
    allow data to move from component to component without having to move data from
    one class instance to another.


* Software requirements

	* Java 1.6 Runtime Environment or higher
	
	* A component & the latest distribution of Grouper Foundation Classes (GFC) on the classpath
	
	* See {{{./distribution-management.html}distribution}} for Maven dependencies.
	\
	\ 

* Work-flow

	GFC employs a DTO paradigm - package, process, and unload - to achieve component processing.  The workflow diagram below 
	demostrates an application's interaction with GFC from start to finish.
	\ 

[./images/process_flow.png] GFC Component Creation & Usage
	\
	\ 

* Requesting a Component

	Available components are enumerated as <<<ComponentType>>> in the 
	<<<com.mmm.his.cer.foundation>>> package.  A <<<ComponentType>>> and <<<Release>>> are
	required to instantiate a component from the <<<ComponentFactory>>>.
	\
	\ 

** Locating a Release

	<<<Release>>> implementations will be provided by each component.  Each release
	can be found in the <<<com.mmm.his.cer.[component_name]>>> package - e.g.,

+---
com.mmm.his.cer.foundation.demo.PfpRelease;
+---

	Releases provide a semantic numbering convention for each component - quarterly, major, minor, and/or bug fix
	\
	\ 
	 
** Component Factory

	GFC provides a ComponentFactory several scenarios to construct instances.  
        The first using a <<<ComponentType>>> and <<<Release>>> and an additional 
        consuming a generic option argument or with a path to the .ctl, for those 
        components that include such files.  In most cases 'R' is reserved for 
        Longitudinal components, such as PFP, or CRG, but be sure to check the 
        component-specific documentation for the appropriate signature to use.

+--
package com.mmm.his.cer.foundation.factory;

public static <I extends IClaim,
		K extends Enum<K>,
		O extends ComponentRuntime<K>> 
		Processable<I, K, O> createComponent(ComponentType type, Release release, O option) throws FoundationException
   
public static <I extends IClaim,
	 	K extends Enum<K>,
	 	O extends ComponentRuntime<K>> 
    	Processable<I, K, O> createComponent(ComponentType type, Release release) throws FoundationException 

public static <I extends IClaim, 
                K extends Enum<K>, 
                O extends ComponentRuntime<K>>
          Processable<I, K, O> createComponent(ComponentType type, Release release, O option, File ctlPath) throws FoundationException {

+--

	GFC will return each component as an instance of the <<<Processable>>> interface to simplify interactions as it only
	surfaces functionality to process, reconfigure, and close.

* Component Record as IClaim

    Each component has its own record, which extension of IClaim.  This is very 
    generic allowing for any data within the record.

* Component Resources

	Components delivered by C&ER may require resources to run properly, such as a .CTL file or a properties file. GFC components may package resources required by the component 
	directly into the component jar. In this scenario, it is not necessary for users to worry about resource placement 
	on the target file system or providing the component with a path to resource files.  By default, resources will be extracted
	to the location designated by the JVM property <<<java.io.tmpdir>>>.  GFC also provides an override to this property (in order to
	preserve the default property value) as <<<gfc.resource.path>>>.  However, creating a component using the
        <<<ctlPath>>> parameter gives a user direct control of where the resources files will be extracted to.
	
	The first time a component is instantiated, GFC checks the target file system to see if the necessary files are available. If 
	unavailable, GFC will write out all the component resources from the component jar.  If the resources are available on the target system, 
	GFC skips writing the resources and uses the component resources found on the target system.

** Checksums

	GFC uses SHA checksums on the component resources to be able to identify when a component resource has been changed and/or updated. 
	When a component resource is packaged into the component jar, a SHA checksum is created for that resource. When GFC looks for component 
	resources on the target file system, if any are found, it then compares the checksum of the file found, with the checksum of the file 
	contained in the jar, if they match, nothing is written out and the file currently on the system is used. If the checksums do not match, 
	this signals that a change has been made and the file currently on the system is replaced with the file that is in the component jar.
	\
	\ 

* Invoking Process

	Each component of GFC implements the <<<Processable>>> interface exposing the process method.  The process method requires the usage of
	any object implementing the <<<IClaim>>> interface.  

        In the example below, we use the PFP version 2.1.0 component.
        Notice that PFP component is not directly used, but instead a Processable with PFP related claim and options.
        However, the example creates the PFP claim directly and uses that for the component's input.  When the 
        component processes the claim, data it put back onto the claim (such as Grouper return code)
        that is pulled off after processing.
	
+---
import com.mmm.his.cer.pfp.PfpClaim;
import com.mmm.his.cer.pfp.PfpRuntimeOption;
import com.mmm.his.cer.foundation.Processable;

public static void main(String args[]) {
	/**
	 * create a new input instance
	 * populate the necessary inputs
	 * see component-specific documentation for input fields
	**/
	PfpClaim claim = new PfpClaim();
	input.setSomething("...");

	//set the analysis date for processing
	PfpRuntimeOption pfpOpt = new PfpRuntimeOption(new GfcDate("11112015"));

	//use the component factory to create an instance
	Processable<PfpClaim, PfpOption, PfpRuntimeOption> component 
		= ComponentFactory.createComponent(ComponentType.Pfp, PfpRelease.v02_1_0, pfpOpt);
		
	//process...
	component.process(input);

	//unload outputs
	input.getSomething();
	
	component.close();
}
+--- 
	\
	\ 

** Reconfiguration

	Certain components allowing runtime reconfiguration through the <<<reconfigure(O option)>>> method (where O is the type 
	defined by a particular component implementation) of the <<<Processable>>> interface. 

+--
public void reconfigure(O options) throws FoundationException;
+--

	Please check the component-specific documentation for reconfiguration parameters.
	\
	\ 